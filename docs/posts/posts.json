[
  {
    "path": "posts/2023-05-15-rallicagram/",
    "title": "Rallicagram",
    "description": "I made a R wrapper for the Gallicagram API. It provides direct access to a set of French corpora and enables to easily run NLP analyses on these corpora.",
    "author": [],
    "date": "2023-05-15",
    "categories": [
      "R",
      "NLP",
      "Package"
    ],
    "contents": "\nrallicagram is a R wrapper for the Gallicagram API. More info can be found on rallicagram website and in particular in its main vignette.\nIn a nutshell, it enables to easily and quickly run some basic Natural Language Processing analyzes on a set of French corpora.\nFor instance, I use rallicagram to analyze discourses around the environment in France. One line of code is enough to describe the newspaper coverage of a specific term between 1970 and today. Here, “climatique”, in the Le Monde newspaper:\n\n\nlibrary(rallicagram)\n\ngallicagram(\n  keyword = \"climatique\", \n  corpus = \"lemonde\", \n  from = 1970, \n  to = 2022,\n  resolution = \"monthly\"\n) \n\n\n\ndate\nkeyword\nn_occur\nn_total\nprop_occur\nyear\nmonth\ncorpus\nresolution\nn_of\n1970-01-01\nclimatique\n0\n1531953\n0.0e+00\n1970\n1\nlemonde\nmois\n1-grams\n1970-02-01\nclimatique\n1\n1397871\n7.0e-07\n1970\n2\nlemonde\nmois\n1-grams\n1970-03-01\nclimatique\n1\n1377684\n7.0e-07\n1970\n3\nlemonde\nmois\n1-grams\n1970-04-01\nclimatique\n1\n1482116\n7.0e-07\n1970\n4\nlemonde\nmois\n1-grams\n1970-05-01\nclimatique\n2\n1531886\n1.3e-06\n1970\n5\nlemonde\nmois\n1-grams\n1970-06-01\nclimatique\n0\n1544520\n0.0e+00\n1970\n6\nlemonde\nmois\n1-grams\n\nHere is the plot of the time series obtained:\n\n\n\nThis package also allows to run more thorough analyzes. For instance, it enables to study the context in which keywords are used. Here is an example from my project on environmental representations:\n\n\n\nMore info on Gallicagram and its API can be found on a preprint by Gallicagram developers Benoît de Courson and Benjamin Azoulay, on the “Notice” tab of the Gallicagram website and on the API documentation. I built the wrapper through discussions with Benoît and Benjamin. It enabled us to develop a few additional API routes in order to offer to users the possibility of running more thorough NLP analyzes directly through the API.\n\n\n\n",
    "preview": "posts/2023-05-15-rallicagram/gallicagram_climatique.png",
    "last_modified": "2023-11-24T21:34:52-05:00",
    "input_file": {},
    "preview_width": 6500,
    "preview_height": 5200
  },
  {
    "path": "posts/2022-10-13-running-simulations/",
    "title": "A workflow to run simulations",
    "description": "In this short document I present a simple workflow I use to run simulations for regression analysis in R.",
    "author": [],
    "date": "2022-10-13",
    "categories": [
      "R",
      "Simulations",
      "Tutorial"
    ],
    "contents": "\nThis document describes the workflow I use to run fake-data simulations for regression analysis in R. At the end of the document one can find a template to run a simple simulation from A to Z. It can be copied/pasted and easily adapted to address specific questions.\nI developed this workflow with Léo Zabrocki. On the website of one of our projects, we describe how we ran more advanced fake data simulations for various causal inference methods (IV, event-study, RDD, matching). On the website of another project, we describe how we ran simulations based on real data, also for various causal inference methods.\nThe workflow described here builds on purrr and tidyverse principles. This framework enables to easily and explicitly run simulations for several sets of parameter values. It also offers the possibility to very easily parallelize the code using the package furrr.\nSimulation workflow\nDefine a set of baseline parameters and store them in a data frame,\nGenerate data for a given set of parameters,\nRun the estimation and extract the outcomes of interest,\nCompute one simulation by combing the previous steps,\nReplicate the process for a number of iterations and a set of parameters.\nDetailed explanation\nTo illustrate this workflow, consider an example from an extremely simple setting. In this example, the goal is to study how the distribution of an estimator varies with the variance of the associated variable. Let’s consider the following model:\n\\[ y_i = \\alpha + \\beta x_i + u_i \\]\nfor individual \\(i \\in \\{1, .., N\\}\\) where \\(u_i \\sim \\mathcal{N}(0, \\sigma_u^2)\\) and \\(x_i \\sim \\mathcal{N}(\\mu_x, \\sigma_x^2)\\).\nPackages\nFirst, I load the packages necessary to run the simulation. Here I also load an additional and a non-necessary package to set my default ggplot theme for graphs, mediocrethemes.\n\n\n#necessary packages\nlibrary(tidyverse)\nlibrary(broom)\n\n#additional packages\nlibrary(mediocrethemes) #my ggplot theme package\nmediocrethemes::set_mediocre_all(gradient = \"right\") #will create all the graphs\n#using my theme\n\n\nDefine a set of baseline parameters\nI store the values of the baseline parameters in a one-row tibble, baseline_param:\n\n\nbaseline_param <- tibble(\n  N = 1000,\n  mu_x = 1.2, \n  sigma_x = 0.9,\n  sigma_u = 0.8,\n  alpha = 0.5,\n  beta = 0.9\n)\n\n\n\n\n\n\nGenerate data\nI then write a function that takes these parameters as inputs and returns a randomly generated data set:\n\n\ngenerate_data <- function(N,\n                          mu_x,\n                          sigma_x,\n                          sigma_u, \n                          alpha,\n                          beta) {\n  \n  data <- tibble(id = 1:N) %>%\n    mutate(\n      x = rnorm(N, mu_x, sigma_x),\n      u = rnorm(N, 0, sigma_u),\n      y = alpha + beta*x + u\n    )\n}\n\n\nOne can pass the parameters to the function using the pmap_dfr function for instance:\n\n\nexample_data <- purrr::pmap_dfr(baseline_param, generate_data)\n\n\n\n\n\n\nRun the estimation\nI then write a function that takes the generated data as input, runs the estimation and returns the parameters of interest in a data frame. In this example, I am interested in estimates of \\(\\beta\\) and therefore only consider the regression output for the \\(x\\) term.\n\n\nrun_estim <- function(data) {\n  lm(data = data, y ~ x) %>%\n    broom::tidy() %>%\n    filter(term == \"x\") \n}\n\n\nThis function, applied to example_data, returns the following data set:\n\nterm\nestimate\nstd.error\nstatistic\np.value\nx\n0.93\n0.03\n33.74\n0\n\nCompute simulation\nI then combine generate_data and run_estim into a function that computes one iteration of the simulation. I also add a line of code to store the parameters used in this simulation.\n\n\ncompute_sim <- function(...) {\n  generate_data(...) %>% \n    run_estim() %>% \n    cbind(as_tibble(list(...))) #add parameters used for generation\n}\n\n\nReplicate the process\nTo run several iterations of the simulation, I build a data frame of parameters such that each row contains the values of the parameters for one single iteration of the simulation.\nIf one wants to run n_iter iterations of the simulation for the baseline parameter values, they only have to replicate the one-row tibble baseline_param using crossing for instance.\n\n\nn_iter <- 5\n\nparam <- baseline_param %>% \n  crossing(rep_id = 1:n_iter) %>% \n  select(-rep_id) \n\n\nIt produces a data frame with n_iter (here 5) identical rows:\n\nN\nmu_x\nsigma_x\nsigma_u\nalpha\nbeta\n1000\n1.2\n0.9\n0.8\n0.5\n0.9\n1000\n1.2\n0.9\n0.8\n0.5\n0.9\n1000\n1.2\n0.9\n0.8\n0.5\n0.9\n1000\n1.2\n0.9\n0.8\n0.5\n0.9\n1000\n1.2\n0.9\n0.8\n0.5\n0.9\n\nThen I cna pass the resulting set of parameter values to the function compute_sim using pmap_dfr:\n\n\nresult_sim <- pmap_dfr(param, compute_sim)\n\n\nUsing this method, one can also easily run a series of simulations for several parameter values. Here, I vary sigma_x and run n_iter iterations of the simulation for each value of the varying parameter sigma_x.\n\n\nn_iter <- 5\n\nvect_sigma_x <- c(0.2, 0.8)\n\nparam_sigma_x <- baseline_param %>% \n  crossing(rep_id = 1:n_iter)  %>% \n  select(-sigma_x) %>% \n  crossing(sigma_x = vect_sigma_x) %>% \n  select(-rep_id) \n\n\nIt produces a data frame with n_iter times the number of values for the varying parameter rows (here 5 times 2 simulations):\n\nN\nmu_x\nsigma_u\nalpha\nbeta\nsigma_x\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\n\nI can then pass this data frame to compute_sim to obtain my simulation results.\n\n\nresult_sim_sigma_x <- pmap_dfr(param_sigma_x, compute_sim)\n\n\nHere are the results!\n\nterm\nestimate\nstd.error\nstatistic\np.value\nN\nmu_x\nsigma_u\nalpha\nbeta\nsigma_x\nx\n0.7919152\n0.1262817\n6.271021\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\nx\n0.9077674\n0.0309158\n29.362533\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\nx\n0.9630684\n0.1279793\n7.525188\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\nx\n0.9009793\n0.0315959\n28.515721\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\nx\n1.0628069\n0.1300458\n8.172556\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\nx\n0.9083459\n0.0314618\n28.871383\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\nx\n0.8016967\n0.1304078\n6.147612\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\nx\n0.8811167\n0.0323071\n27.273188\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\nx\n0.6900479\n0.1242532\n5.553564\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.2\nx\n0.9149920\n0.0315210\n29.028001\n0\n1000\n1.2\n0.8\n0.5\n0.9\n0.8\n\nParallel computing\nThe simulation process can easily be parallelized using furrr. To do so, I use future_pmap_dfr instead of pmap_dfr. To do that, I need to first define the type of session to use and potentially set the seed option to TRUE.\n\n\nlibrary(furrr)\n\nfuture::plan(multisession, workers = availableCores() - 1)\n\nresult_sim <- future_pmap_dfr(param, compute_sim,\n        .options = furrr_options(seed = TRUE))\n\n\nAnalysis of the results\nI then briefly analyse the output of this simulation. In this example, I am interested in studying how the distribution of the estimates varies with the value of \\(\\sigma_x\\). I therefore run a longer simulation with 500 iterations and 4 values for \\(\\sigma_x\\).\n\n\n\nI then make the graph of interest:\n\n\nresult_sim_long %>% \n  mutate(sigma_x = as.factor(sigma_x)) %>% \n  ggplot() +\n  geom_density(aes(x = estimate, color = sigma_x), alpha = 0.03) +\n  labs(\n    title = \"Distribution of estimates of beta\",\n    subtitle = \"Comparison for different values of the standard deviation of x\",\n    color = \"sd(x)\",\n    fill = \"sd(x)\",\n    x = \"Estimate of beta\",\n    y = \"Density\"\n  )\n\n\n\nEach distribution is built based on 500 points (estimates). This graph illustrates a well know result: the distribution of the estimates widens when \\(\\sigma_x\\) decreases.\nA simple template\nThe following code summarizes the previous chunks. One can thus easily copy/paste the entire simulation to adapt it to a specific context.\n\n\n#packages and set cores\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(furrr)\n\nfuture::plan(multisession, workers = availableCores() - 1)\n\n#set baseline parameters\nbaseline_param <- tibble(\n  N = 1000,\n  mu_x = 1.2, \n  sigma_x = 0.9,\n  sigma_u = 0.8,\n  alpha = 0.5,\n  beta = 0.9\n)\n\n#function to generate data\ngenerate_data <- function(N,\n                          mu_x,\n                          sigma_x,\n                          sigma_u, \n                          alpha,\n                          beta) {\n  \n  data <- tibble(id = 1:N) %>%\n    mutate(\n      x = rnorm(N, mu_x, sigma_x),\n      u = rnorm(N, 0, sigma_u),\n      y = alpha + beta*x + u\n    )\n}\n\n#function to run the estimation\nrun_estim <- function(data) {\n  lm(data = data, y ~ x) %>%\n    broom::tidy() %>%\n    filter(term == \"x\") \n}\n\n#function to compute a simulation\ncompute_sim <- function(...) {\n  generate_data(...) %>% \n    run_estim() %>% \n    cbind(as_tibble(list(...))) #add parameters used for generation\n}\n\n#replicate the process\n#set the number of iterations and parameters to vary\nn_iter <- 1000\nvect_sigma_x <- seq(0.2, 2, 0.2)\n#define the complete set of parameters\nparam <- baseline_param %>% \n  crossing(rep_id = 1:n_iter)  %>% \n  select(-sigma_x) %>% \n  crossing(sigma_x = vect_sigma_x) %>% \n  select(-rep_id) \n\nresult_sim <- future_pmap_dfr(param, compute_sim,\n        .options = furrr_options(seed = TRUE))\n\n\n1\n\nThe thumbnail photo: Maxime Lebrun on Unsplash↩︎\n",
    "preview": "posts/2022-10-13-running-simulations/spiral.jpg",
    "last_modified": "2023-10-15T14:14:03-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-06-22-mediocrethemes/",
    "title": "mediocrethemes",
    "description": "I made a small R package providing ready to use ggplot themes. Setting the theme for all graphs in a document only requires one short line of code.",
    "author": [],
    "date": "2021-06-22",
    "categories": [
      "R",
      "Data viz",
      "ggplot",
      "Package"
    ],
    "contents": "\nmedoiocrethemes is a small R package providing ready to use ggplot themes that are, in my opinion, not strikingly nice but, hopefully, not strikingly ugly either (hence the name of the package). More info and vignettes to get familiar with the package can be found on the package website.\nTo me, the function set_mediocre_all() is the most useful feature of my package. When called at the beginning of the code, all subsequent graphs will be created using the new theme, without any additional line of code. This function enables users to easily depart from the nice but too often seen base ggplot theme and color scheme.\nI tried my best to make my code reproducible. Users should be able to easily adapt my code to create their own theme and color scheme. The code for this package can be find on the GitHub page of the package.\nThe base color palette is:\n\n\n\nHere are a couple of example plots build using the theme and main color scale. A lot more graphs and color scales can be seen on the package website.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI also created a xaringan slide template in a style consistent with mediocrethemes:\n\n\n\nThis is a simple an application of the xaringanthemer package and can be very easily set up with the function mediocrethemes::xaringan_mediocre(), as explained in this vignette.\n\n\n\n",
    "preview": "posts/2021-06-22-mediocrethemes/mediocrethemes_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2023-10-15T10:57:39-04:00",
    "input_file": {},
    "preview_width": 3900,
    "preview_height": 2400
  }
]
